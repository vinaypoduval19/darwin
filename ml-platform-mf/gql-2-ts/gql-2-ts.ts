#!/usr/bin/env node

import fromQuery from '@gql2ts/from-query'
import DEFAULT_OPTIONS from '@gql2ts/language-typescript'
import {format as prettyFormat} from 'prettier'
import {getValidatorsFromString} from './ts-2-iots'

import * as fs from 'fs-extra'
import * as Glob from 'glob'
import * as graphql from 'graphql'
import * as path from 'path'
import {promisify} from 'util'

const NO_OF_DIRECTORIES_OFFSET = 2
const {Kind} = graphql
const glob = promisify(Glob as any)
const formatConfig = {
  singleQuote: true,
  jsxSingleQuote: true,
  semi: false,
  bracketSpacing: false
}

const readFile = promisify<string, Buffer>(fs.readFile)
const writeFile = <(file: string, content: string) => void>(
  promisify(fs.writeFile)
)

const removeWhiteSpace = (q: string) =>
  q.replace(/\n/g, '').replace(/\s\s*/g, ' ')

const identity = <T>(arg: T): T => arg

const getAutogenerationComment = (fileName: string) =>
  `/**
 * This file is autogenerated from gql:compile script using ${fileName} .
 * Any changes made to this file will be overwritten in build.
 * It won't be committed into git.
 **/\n`

const titleCaseToHyphen = (str: string) =>
  str
    .replace(/[A-Z]/, function (g) {
      return g.toLowerCase()
    })
    .replace(/[A-Z]/g, function (g) {
      return '-' + g.toLowerCase()
    })

const writeEnumsFile = (
  enumName: string,
  enumData: string,
  rootPath: string
) => {
  try {
    const enumFileName = titleCaseToHyphen(enumName)
    return writeFile(
      `${rootPath}/gql-enums/${enumFileName}.enum.ts`,
      `${getAutogenerationComment('graphql.schema.json')}\n${enumData}`
    )
  } catch (e) {
    console.log(`FAILED  to write enums file : ${enumName}\n\n`, e) //tslint:disable-line
    process.exit(1)
  }
}

const getEnumImportText = (
  enumNames: string[],
  noOfDirectoriesToGoUp: number
) =>
  enumNames
    .map(
      (enumName) =>
        `import {${enumName}} from '${'../'.repeat(
          noOfDirectoriesToGoUp
        )}gql-enums/${titleCaseToHyphen(enumName)}.enum'`
    )
    .join('\n')

const parseQuery = (
  data: string,
  queryString: string,
  filePath: string,
  processingDirectory: string
) => {
  let enumsData: EnumData = {}
  const saveEnumData = (enumName: string, enumText: string) => {
    enumsData[enumName] = DEFAULT_OPTIONS.postProcessor(
      'export ' + DEFAULT_OPTIONS.enumTypeBuilder(enumName, enumText)
    )
    return ''
  }

  const customFormattersWithoutEnums = {
    interfaceBuilder: (name: string, body: string) =>
      'export ' + DEFAULT_OPTIONS.interfaceBuilder(name, body),
    enumTypeBuilder: saveEnumData,
    typeBuilder: (name: string, body: string) =>
      'export ' + DEFAULT_OPTIONS.typeBuilder(name, body),
    exportFunction: identity
  }

  const parsedQuery = fromQuery(
    data,
    queryString,
    {},
    customFormattersWithoutEnums
  ).map((i) => i.result)

  const enumNames = Object.keys(enumsData)
  const fileName = filePath.replace(/.*\/(.*).graphql/, '$1')
  const noOfDirectoriesToGoUp =
    filePath.replace(new RegExp('.*' + processingDirectory), '').split(path.sep)
      .length - NO_OF_DIRECTORIES_OFFSET
  const definitionsFileText = [
    getAutogenerationComment(fileName + '.graphql'),
    `import {OperationTypeNode} from 'graphql'`,
    // Add import only when there are enums in the file
    enumNames.length ? getEnumImportText(enumNames, noOfDirectoriesToGoUp) : '',
    ...parsedQuery,
    `export interface GraphQLWrapper {
  query: string
  name: string
  operation: OperationTypeNode
 }`,
    `export declare const GQL: GraphQLWrapper`
  ].join('\n')

  return {enumsData, definitionsFileText}
}

const getQueryJSText = (queryString: string) => {
  const AST = graphql.parse(queryString)

  /**
   * Filter out any Fragments if they're defined
   * */
  const arrNodeDefinition = AST.definitions.filter(
    (node) => node.kind === Kind.OPERATION_DEFINITION
  ) as Array<graphql.OperationDefinitionNode>

  /**
   * Typings get generated for last-defined node in the file
   * */
  const OperationNode = arrNodeDefinition[arrNodeDefinition.length - 1]

  const {
    operation,
    name: {value: queryName} = {value: 'UnknownQueryOrMutation'}
  } = OperationNode

  const queryJS = `exports.GQL = {query:'${removeWhiteSpace(
    queryString
  )}',name:'${queryName}',operation:'${operation}'}`
  return queryJS
}

const compileFile = async (
  filePath: string,
  data: string,
  processingDirectory: string
) => {
  try {
    const queryString = (await readFile(filePath)).toString()
    const queryJSText = getQueryJSText(queryString)
    const parsedOutput = parseQuery(
      data,
      queryString,
      filePath,
      processingDirectory
    )

    const res = getValidatorsFromString(parsedOutput.definitionsFileText)

    const filesToWrite = [
      writeFile(
        `${filePath.replace('.graphql', '.d.ts')}`,
        parsedOutput.definitionsFileText
      ),
      writeFile(
        `${filePath.replace('.graphql', '.gqlTypes.ts')}`,
        prettyFormat(res, formatConfig)
      ),
      writeFile(
        `${filePath.replace('.graphql', 'Gql.js')}`,
        prettyFormat(queryJSText, formatConfig)
      )
    ]
    await Promise.all(filesToWrite)
    return parsedOutput.enumsData
  } catch (e) {
    console.log(`FAILED: ${filePath}\n\n`, e) //tslint:disable-line
    process.exit(1)
  }
}

type EnumData = {
  [key: string]: string
}

const main = async () => {
  const {data} = await fs.readJSON('graphql.schema.json')
  const args = process.argv.slice(2)
  for (let i = 0; i < args.length; i++) {
    const cwd = path.resolve(process.cwd(), args[i])
    const files = await glob('**/*.graphql', {
      cwd: cwd
    })

    const allEnumsArray = await Promise.all(
      files
        .map((i) => path.resolve(cwd, i))
        .map((path) => compileFile(path, data, args[i]))
    )

    const enumsData: EnumData = {}
    allEnumsArray.forEach((enumsMap) => {
      if (enumsMap) {
        Object.keys(enumsMap).forEach((enumName) => {
          enumsData[enumName] = enumsMap[enumName]
        })
      }
    })

    const allEnums = Object.keys(enumsData)
    await Promise.all(
      allEnums.map((enumName) =>
        writeEnumsFile(enumName, enumsData[enumName], args[i])
      )
    )

    console.log(`Compiled ${files.length} files inside ${args[i]}`) // tslint:disable-line
  }
}

main().catch((err) => {
  console.error(err) // tslint:disable-line
  process.exit(1)
})
